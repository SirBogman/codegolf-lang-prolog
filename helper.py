#!/usr/bin/env python3

import re
from itertools import groupby

def split_operator(line):
    a, b, c = line.split()
    return int(a), b, c

def escape_style_tag(name):
    if name == '.':
        # Need to use a special name for the external tokenizer.
        return 'Dot'
    name = name.replace('\\', '\\\\')
    if '/' in name or '!' in name or '*' in name or '...' in name:
        return f'"{name}"'.replace('\\', '\\\\')
    return name

# This operator data string is generated by the following Prolog code with swipl:
# :-use_module(library(clpfd)).
# :-current_op(X,Y,Z),format('~d ~s ~s',[X,Y,Z]),\+nl.
# Note: I changed "750 yfx #<==" to "755 yfx #<==" to prevent a shift/reduce conflict.
operator_data = [split_operator(x) for x in '''
1 fx $
100 yfx .
200 fy +
200 fy -
200 fy \\
200 xfx **
200 xfy ^
400 yfx *
400 yfx /
400 yfx //
400 yfx <<
400 yfx >>
400 yfx div
400 yfx mod
400 yfx rdiv
400 yfx rem
400 yfx xor
450 xfx ..
500 yfx +
500 yfx -
500 yfx /\\
500 yfx \\/
600 xfy :
700 xfx #<
700 xfx #=
700 xfx #=<
700 xfx #>
700 xfx #>=
700 xfx #\\=
700 xfx :<
700 xfx <
700 xfx =
700 xfx =..
700 xfx =:=
700 xfx =<
700 xfx ==
700 xfx =@=
700 xfx =\\=
700 xfx >
700 xfx >:<
700 xfx >=
700 xfx @<
700 xfx @=<
700 xfx @>
700 xfx @>=
700 xfx \\=
700 xfx \\==
700 xfx \\=@=
700 xfx as
700 xfx in
700 xfx in_set
700 xfx ins
700 xfx is
710 fy #\\
720 yfx #/\\
730 yfx #\\
740 yfx #\\/
750 xfy #==>
755 yfx #<==
760 yfx #<==>
800 xfx :=
900 fy \\+
1000 xfy ,
1050 xfy *->
1050 xfy ->
1100 xfy ;
1105 xfy |
1150 fx discontiguous
1150 fx dynamic
1150 fx initialization
1150 fx meta_predicate
1150 fx module_transparent
1150 fx multifile
1150 fx public
1150 fx table
1150 fx thread_initialization
1150 fx thread_local
1150 fx volatile
1200 fx :-
1200 fx ?-
1200 xfx -->
1200 xfx :-
1200 xfx =>
'''.strip().splitlines(keepends=False)]

last_precedence = 0

all_except_words = {name for (_, _, name) in operator_data if not re.match("\\w+", name)}
unary = {name for (_, op_type, name) in operator_data if len(op_type) == 2 and not re.match("\\w+", name)}
binary = {name for (_, op_type, name) in operator_data if len(op_type) == 3 and not re.match("\\w+", name)}

def make_name(name):
    if name == '.':
        # Need to use a special name for the external tokenizer.
        return 'Dot'
    if re.match("\\w+", name):
        return f'kw<"{name}">'
    return f'"{name}"'.replace('\\', '\\\\')

def make_rule(op_type, names, term, last_term):
    names_string = make_name(names[0]) if len(names) == 1 else '(' + ' | '.join(map(make_name, names)) + ')'
    if op_type == 'fx':
        return f'UnaryOperation {{ {names_string} {last_term} }} | // {op_type}'
    if op_type == 'fy':
        return f'UnaryOperation {{ {names_string} {term} }} | // {op_type}'
    if op_type == 'xfx':
        return f'BinaryOperation {{ {last_term} {names_string} {last_term} }} | // {op_type}'
    if op_type == 'xfy':
        return f'BinaryOperation {{ {last_term} {names_string} {term} }} | // {op_type}'
    if op_type == 'yfx':
        return f'BinaryOperation {{ {term} {names_string} {last_term} }} | // {op_type}'
    raise Exception(f'Unknown operator type: {op_type}')

for precedence, g in groupby(sorted(operator_data), key=lambda x:x[0]):
    term = f'term{precedence}'
    last_term = f'term{last_precedence}'
    print(f'{term} {{')
    for op_type, g2, in groupby(sorted(g), key=lambda x:x[1]):
        print(f'  {make_rule(op_type, [x[2] for x in g2], term, last_term)}')
    print(f'  {last_term}')
    print('}')
    print()
    last_precedence = precedence

def wrap(items, join, width, indent):
    result = ''
    line = indent
    for index, item in enumerate(items):
        if index < len(items) - 1 and join:
            item += ' ' + join

        if index == 0:
            line += item
        elif len(item) + 1 + len(line) <= width:
            line += ' ' + item
        else:
            result += '\n' + line
            line = indent + item

    if result:
        result += '\n' + line
    else:
        result = line

    return result

print("Binary only (for atom rule):")
print(wrap(sorted(make_name(x) for x in sorted(binary - unary)), '|', 100, '  '))
print()

print("Style tags (for index.ts):")
print("'" + ' '.join(sorted({escape_style_tag(x) for (_, _, x) in operator_data})) + "': t.operator,")
print()

print("All except words (for @tokens)")
print(wrap([make_name(x) for x in sorted(all_except_words - {'.'})], '', 100, '  '))
print()
